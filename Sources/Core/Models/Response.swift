public struct Response: Identifiable, Equatable, Hashable, Codable, Sendable {
	public struct Config: Equatable, Hashable, Codable, Sendable {
		public enum Conversation: String, Equatable, Hashable, Codable, Sendable {
			/// The contents of the response will be added to the default conversation.
			case auto
			/// An out-of-band response which will not add items to default conversation.
			case none
		}

		/// The modalities for the response.
		public let modalities: [Session.Modality]

		/// Instructions for the model.
		public let instructions: String

		/// The voice the model uses to respond.
		public let voice: Session.Voice

		/// The format of output audio.
		public let outputAudioFormat: Session.AudioFormat

		/// Tools (functions) available to the model.
		public let tools: [Tool]

		/// How the model chooses tools.
		public let toolChoice: Tool.Choice

		/// Sampling temperature.
		public let temperature: Double

		/// Maximum number of output tokens.
		public let maxResponseOutputTokens: Int?

		/// Controls which conversation the response is added to.
		public let conversation: Conversation?

		/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
		public let metadata: [String: String]?

		/// Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation.
		public let input: [Item]?

		public init(modalities: [Session.Modality], instructions: String, voice: Session.Voice, outputAudioFormat: Session.AudioFormat, tools: [Tool], toolChoice: Tool.Choice, temperature: Double, maxResponseOutputTokens: Int?, conversation: Conversation?, metadata: [String: String]?, input: [Item]?) {
			self.modalities = modalities
			self.instructions = instructions
			self.voice = voice
			self.outputAudioFormat = outputAudioFormat
			self.tools = tools
			self.toolChoice = toolChoice
			self.temperature = temperature
			self.maxResponseOutputTokens = maxResponseOutputTokens
			self.conversation = conversation
			self.metadata = metadata
			self.input = input
		}
	}

	public enum Status: String, Equatable, Hashable, Codable, Sendable {
		case failed
		case completed
		case cancelled
		case incomplete
		case inProgress = "in_progress"
	}

	public enum Usage: Equatable, Hashable, Sendable {
		case tokens(TokenUsage)
		case duration(DurationUsage)
		
		public struct TokenUsage: Equatable, Hashable, Codable, Sendable {
			public let totalTokens: Int
			public let inputTokens: Int
			public let outputTokens: Int
			public let inputTokenDetails: InputTokenDetails
			public let outputTokenDetails: OutputTokenDetails

			public struct InputTokenDetails: Equatable, Hashable, Codable, Sendable {
				public let textTokens: Int
				public let audioTokens: Int
				public let cachedTokens: Int
				public let cachedTokensDetails: CachedTokensDetails

				public struct CachedTokensDetails: Equatable, Hashable, Codable, Sendable {
					public let textTokens: Int
					public let audioTokens: Int
				}
			}

			public struct OutputTokenDetails: Equatable, Hashable, Codable, Sendable {
				public let textTokens: Int
				public let audioTokens: Int
			}
		}
		
		public struct DurationUsage: Equatable, Hashable, Codable, Sendable {
			public let type: String  // "duration"
			public let seconds: Int
		}
	}

	/// The unique ID of the response.
	public let id: String

	/// The status of the response.
	public let status: Status

	/// The list of output items generated by the response.
	public let output: [Item]

	/// Which conversation the response is added to.
	public var conversationId: String?

	/// Usage statistics for the response.
	public let usage: Usage?

	/// Developer-provided string key-value pairs associated with this response.
	public let metadata: [String: String]?
}

// MARK: - Usage Codable Implementation
extension Response.Usage: Codable {
	private enum CodingKeys: String, CodingKey {
		case type
	}
	
	public init(from decoder: any Decoder) throws {
		// 尝试解码为 duration-based
		if let container = try? decoder.container(keyedBy: CodingKeys.self),
		   let type = try? container.decode(String.self, forKey: .type),
		   type == "duration" {
			self = try .duration(DurationUsage(from: decoder))
			return
		}
		
		// 否则尝试解码为 token-based
		self = try .tokens(TokenUsage(from: decoder))
	}
	
	public func encode(to encoder: any Encoder) throws {
		switch self {
		case .tokens(let usage):
			try usage.encode(to: encoder)
		case .duration(let usage):
			try usage.encode(to: encoder)
		}
	}
}

// MARK: - Usage Convenience Properties
extension Response.Usage {
	public var totalTokens: Int? {
		if case .tokens(let usage) = self {
			return usage.totalTokens
		}
		return nil
	}
	
	public var durationSeconds: Int? {
		if case .duration(let usage) = self {
			return usage.seconds
		}
		return nil
	}
}
